# Динамическое программирование

Динамическое программирование — это метод решения сложных задач путём их разбиения на более простые подзадачи.

## Алгоритмы

*   **Abbreviation**
    *   Определяет, можно ли сократить одну строку, чтобы получить другую.

*   **All Construct**
    *   Находит все возможные способы, которыми строка может быть сконструирована из заданного списка слов.

*   **Bitmask**
    *   Использует битовые маски для решения задач, часто связанных с подмножествами или состояниями.

*   **Catalan Numbers**
    *   Вычисляет числа Каталана, которые встречаются в различных комбинаторных задачах.

*   **Climbing Stairs**
    *   Находит количество различных способов подняться на лестницу из `n` ступенек, если можно шагать на 1 или 2 ступеньки за раз.

*   **Combination Sum IV**
    *   Находит количество всех возможных комбинаций, которые в сумме дают заданное число.

*   **Edit Distance**
    *   Вычисляет минимальное количество операций (вставка, удаление, замена), необходимых для преобразования одной строки в другую.

*   **Factorial**
    *   Вычисляет факториал числа.

*   **Fast Fibonacci**
    *   Реализует быстрый алгоритм для вычисления чисел Фибоначчи.

*   **Fibonacci**
    *   Классическая реализация для вычисления чисел Фибоначчи.

*   **Fizz Buzz**
    *   Классическая задача Fizz Buzz, решённая с использованием динамического программирования.

*   **Floyd Warshall**
    *   Алгоритм для нахождения кратчайших путей между всеми парами вершин во взвешенном графе.

*   **Integer Partition**
    *   Находит количество способов, которыми целое число может быть представлено в виде суммы целых положительных чисел.

*   **Iterating Through Submasks**
    *   Демонстрирует, как итерировать по всем подмаскам данной битовой маски.

*   **K Means Clustering TensorFlow**
    *   Реализация кластеризации методом k-средних с использованием TensorFlow.

*   **Knapsack**
    *   Задача о рюкзаке: определение набора предметов, который максимизирует общую стоимость при ограниченном весе.

*   **Largest Divisible Subset**
    *   Находит наибольшее подмножество, в котором каждый элемент делится на предыдущий.

*   **Longest Common Subsequence**
    *   Находит самую длинную общую подпоследовательность двух последовательностей.

*   **Longest Common Substring**
    *   Находит самую длинную общую подстроку двух строк.

*   **Longest Increasing Subsequence**
    *   Находит длину самой длинной возрастающей подпоследовательности в массиве.

*   **Longest Increasing Subsequence O(n log n)**
    *   Более эффективная реализация поиска самой длинной возрастающей подпоследовательности.

*   **Longest Palindromic Subsequence**
    *   Находит самую длинную палиндромную подпоследовательность в строке.

*   **Matrix Chain Multiplication**
    *   Определяет оптимальный порядок перемножения матриц для минимизации количества скалярных произведений.

*   **Matrix Chain Order**
    *   Другая реализация задачи об оптимальном порядке перемножения матриц.

*   **Max Non Adjacent Sum**
    *   Находит максимальную сумму непоследовательных элементов в массиве.

*   **Max Product Subarray**
    *   Находит подмассив с наибольшим произведением.

*   **Max Subarray Sum**
    *   Находит непрерывный подмассив с наибольшей суммой.

*   **Min Distance Up Bottom**
    *   Реализация задачи о расстоянии редактирования (расстояние Левенштейна) подходом "сверху-вниз".

*   **Minimum Coin Change**
    *   Находит минимальное количество монет, необходимое для сдачи определённой суммы.

*   **Minimum Cost Path**
    *   Находит путь с минимальной стоимостью в матрице от верхнего левого угла до нижнего правого.

*   **Minimum Partition**
    *   Разделяет множество на два подмножества так, чтобы разница их сумм была минимальной.

*   **Minimum Size Subarray Sum**
    *   Находит самый короткий непрерывный подмассив, сумма которого не меньше заданного значения.

*   **Minimum Squares to Represent a Number**
    *   Находит минимальное количество квадратов чисел, которые в сумме дают заданное число.

*   **Minimum Steps to One**
    *   Вычисляет минимальное количество шагов, чтобы свести число к 1 (разрешены операции: -1, /2, /3).

*   **Minimum Tickets Cost**
    *   Вычисляет минимальную стоимость для путешествий в заданные дни с билетами на 1, 7 и 30 дней.

*   **Optimal Binary Search Tree**
    *   Строит оптимальное двоичное дерево поиска для минимизации стоимости поиска.

*   **Palindrome Partitioning**
    *   Находит минимальное количество разрезов, необходимых для разделения строки на палиндромные подстроки.

*   **Regex Match**
    *   Реализует сопоставление с образцом для регулярных выражений с поддержкой `.` и `*`.

*   **Rod Cutting**
    *   Задача о разрезании стержня: находит максимальный доход от продажи кусков стержня.

*   **Smith Waterman**
    *   Алгоритм Смита-Ватермана для локального выравнивания последовательностей.

*   **Subset Generation**
    *   Генерирует все подмножества заданного множества.

*   **Sum of Subset**
    *   Определяет, существует ли подмножество с заданной суммой.

*   **Trapped Water**
    *   Вычисляет, сколько дождевой воды может быть удержано между столбиками разной высоты.

*   **Tribonacci**
    *   Генерирует последовательность Трибоначчи.

*   **Viterbi**
    *   Алгоритм Витерби для нахождения наиболее вероятной последовательности скрытых состояний.

*   **Wildcard Matching**
    *   Реализует сопоставление с образцом с использованием `?` и `*`.

*   **Word Break**
    *   Определяет, можно ли разбить строку на последовательность слов из словаря.

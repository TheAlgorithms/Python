# Алгоритмы на графах

Граф — это абстрактная структура данных, предназначенная для реализации математической концепции графов. Он состоит из набора вершин (или узлов) и набора рёбер, которые соединяют пары вершин.

***Примечание: Этот список может быть неполным из-за проблем с доступом к некоторым файлам в этой директории.***

## Алгоритмы

*   **A\* Search (Поиск A\*)**
    *   Алгоритм поиска, который находит кратчайший путь от начальной до конечной вершины. Он использует эвристическую оценку для определения приоритета узлов.

*   **Ant Colony Optimization (Оптимизация муравьиной колонией)**
    *   Вероятностный метод для решения вычислительных задач, который можно свести к нахождению оптимальных путей в графах. Используется для решения задачи коммивояжёра.

*   **Articulation Points (Точки сочленения)**
    *   Находит все точки сочленения (или шарниры) в неориентированном графе. Точка сочленения — это вершина, удаление которой увеличивает количество компонент связности графа.

*   **Basic Graphs (Базовые графы)**
    *   Содержит набор базовых функций для работы с графами, включая инициализацию, обходы (BFS, DFS), алгоритмы Дейкстры, Прима, Краскала, Флойда-Уоршелла и топологическую сортировку.

*   **Bellman-Ford (Алгоритм Беллмана-Форда)**
    *   Находит кратчайшие пути от одной вершины до всех остальных во взвешенном ориентированном графе. Может работать с рёбрами отрицательного веса и обнаруживать отрицательные циклы.

*   **Bi-directional Dijkstra (Двунаправленный алгоритм Дейкстры)**
    *   Оптимизация алгоритма Дейкстры, которая выполняет поиск одновременно от начальной и конечной вершин, что может значительно ускорить нахождение пути.

*   **Bidirectional A\* (Двунаправленный A\*)**
    *   Комбинация двунаправленного поиска и алгоритма A\*, которая ищет путь от начальной и конечной точек одновременно, используя эвристику для направления поиска.

*   **Bidirectional Breadth-First Search (Двунаправленный поиск в ширину)**
    *   Оптимизация поиска в ширину, выполняющая поиск одновременно из двух точек для более быстрого нахождения пересечения и пути.

*   **Boruvka's Algorithm (Алгоритм Борувки)**
    *   Алгоритм для нахождения минимального остовного дерева (MST) в графе. Итеративно добавляет самые дешёвые рёбра к компонентам связности.

*   **Breadth-First Search (Поиск в ширину, BFS)**
    *   Алгоритм обхода графа, который исследует все вершины на текущем уровне перед переходом на следующий. Используется для нахождения кратчайшего пути в невзвешенных графах.

*   **Check Bipartite (Проверка на двудольность)**
    *   Определяет, является ли граф двудольным (т.е. можно ли его вершины раскрасить в два цвета так, чтобы ни одно ребро не соединяло одноцветные вершины), используя BFS и DFS.

*   **Check Cycle (Проверка на наличие цикла)**
    *   Обнаруживает циклы в ориентированном графе с помощью поиска в глубину (DFS).

*   **Connected Components (Компоненты связности)**
    *   Находит все компоненты связности в неориентированном графе.

*   **Deep Clone Graph (Глубокое копирование графа)**
    *   Создаёт полную, независимую копию графа.

*   **Depth-First Search (Поиск в глубину, DFS)**
    *   Алгоритм обхода графа, который уходит "вглубь" графа, насколько это возможно, прежде чем возвращаться.

*   **Dijkstra's Algorithm (Алгоритм Дейкстры)**
    *   Находит кратчайшие пути от одной вершины до всех остальных во взвешенном графе без рёбер отрицательного веса. В репозитории представлено несколько реализаций.

*   **Dinic's Algorithm (Алгоритм Диница)**
    *   Эффективный алгоритм для нахождения максимального потока в транспортной сети.

*   **Directed and Undirected Weighted Graph (Ориентированные и неориентированные взвешенные графы)**
    *   Классы, реализующие базовые операции для ориентированных и неориентированных взвешенных графов.

*   **Edmonds-Karp (Алгоритм Эдмондса-Карпа - реализация Push-Relabel)**
    *   Файл содержит реализацию алгоритма "поднять-в-начало" (push-relabel) для нахождения максимального потока, а также классы для сетей с несколькими источниками и стоками.

*   **Eulerian Path and Circuit (Эйлеров путь и цикл)**
    *   Определяет и находит эйлеров путь или цикл в неориентированном графе.

*   **Even Tree (Чётное дерево)**
    *   Находит максимальное количество рёбер, которые можно удалить из дерева, чтобы все полученные компоненты имели чётное число вершин.

*   **Finding Bridges (Поиск мостов)**
    *   Находит все мосты в графе (рёбра, удаление которых увеличивает число компонент связности).

*   **Frequent Pattern Graph Miner (Поиск частых паттернов в графах)**
    *   Реализует алгоритм FP-GraphMiner для поиска частых подграфов в наборе графов.

*   **Gale-Shapley Algorithm (Алгоритм Гейла-Шепли)**
    *   Решает задачу о стабильном паросочетании (стабильных браках).

*   **Graph Representations (Представления графов)**
    *   Файлы `graph_adjacency_list.py`, `graph_adjacency_matrix.py`, `graph_list.py` содержат различные реализации структуры данных графа.

*   **Floyd-Warshall (Алгоритм Флойда-Уоршелла)**
    *   Находит кратчайшие пути между всеми парами вершин.

*   **Greedy Best-First Search (Жадный поиск по первому наилучшему совпадению)**
    *   Алгоритм поиска пути, который всегда выбирает узел, наиболее близкий к цели согласно эвристике.

*   **Greedy Minimum Vertex Cover (Жадное вершинное покрытие)**
    *   Аппроксимационный алгоритм для задачи о минимальном вершинном покрытии, выбирающий вершины с наибольшей степенью.

*   **Kahn's Algorithm (Алгоритм Кана)**
    *   Алгоритм для топологической сортировки вершин в ациклическом ориентированном графе, также используется для нахождения самого длинного пути.

*   **Karger's Algorithm (Алгоритм Каргера)**
    *   Вероятностный алгоритм для нахождения минимального разреза в графе.

*   **Markov Chain (Цепь Маркова)**
    *   Моделирует случайное блуждание по графу с заданными вероятностями переходов.

*   **Matching Minimum Vertex Cover (Вершинное покрытие через паросочетание)**
    *   Аппроксимационный алгоритм для задачи о минимальном вершинном покрытии, использующий максимальное паросочетание.

*   **Minimum Path Sum (Минимальная сумма пути)**
    *   Находит путь с минимальной суммой в сетке от верхнего левого до нижнего правого угла.

"""
Content Scramble System (CSS)

Introduced in 1996, the Content Scramble System is a cryptographic
algorithm most notable for use on commercial DVDs.  Inspiration for
CSS comes from principles of circuits and electrical engineering.
Working at the bit level, the CSS algorithm scrambles bits based on
the provided key, two linear feedback shift registers (LFSR) of bit
sizes 16 and 24, and a full adder on the two LFSRs.

The CSS algorithm is notably vulnerable to brute force attacks due
to its small key size of 40 bits.  This is easily seen in this specific
implementation, where the 40 bits are coming from a keyword of 5
characters.  An attacker could simply try and guess 5 characters over
and over to crack the cipher.

There are several key components to the CSS cipher:
* Linear Feedback Shift Register - Using exclusive-or (xor), bits are cycled
upon hitting certain positions in the register via a set of taps,
often conceptualized as a polynomial.  For more information, see:
https://en.wikipedia.org/wiki/Linear-feedback_shift_register

* Full Adder - Best visualized as a truth table, a full adder is a circuit
that utilizes three sets of binary inputs to produce two sets of
binary outputs.  For more information, see:
https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder

* Text to bit conversion - Only 0s and 1s are understood by this
algorithm.  Huge thanks to JFS on Stack Overflow for these functions
to go back and forth between bits and text in Python 3
For more information, see:
https://stackoverflow.com/questions/7396849/convert-binary-to-ascii-and-vice-versa

* Key - A 40 bit key composed of 5 letters, numbers, symbols, spaces,
etc.  This implementation will trim the key to 40 bits if more bits are
provided.  If less are provided or empty, exit.

Created by summonholmes
"""


def text_to_bits(text: str, encoding="utf-8", errors="surrogatepass") -> str:
    """
    Thanks jfs - convert-binary-to-ascii-and-vice-versa

    >>> text_to_bits('Jive Turkey')
    '010010100110100101110110011001010010000001010100011101010111\
0010011010110110010101111001'
    >>> text_to_bits('j1>3_t|_|rK3Y')
    '011010100011000100111110001100110101111101110100011111000101\
11110111110001110010010010110011001101011001'
    """
    bits = bin(int.from_bytes(text.encode(encoding, errors), "big"))[2:]
    return bits.zfill(8 * ((len(bits) + 7) // 8))


def text_from_bits(bits: str, encoding="utf-8", errors="ignore") -> str:
    """
    Thanks jfs - convert-binary-to-ascii-and-vice-versa

    >>> text_from_bits('0100101001101001011101100110010100100000010\
101000111010101110010011010110110010101111001')
    'Jive Turkey'
    >>> text_from_bits('0110101000110001001111100011001101011111011\
1010001111100010111110111110001110010010010110011001101011001')
    'j1>3_t|_|rK3Y'
    """
    n = int(bits, 2)
    return n.to_bytes((n.bit_length() + 7) // 8, "big").decode(encoding, errors) or "\0"


def check_keyword(keyword: str):
    """
    The keyword can be any collection of characters whatsoever, so
    long as the amount of bits is at least 40.  All characters including
    spaces

    >>> check_keyword('shane')
    >>> check_keyword('$hAn3 cAT name amber|')
    """

    # The keyword must be at least 5 characters
    if len(keyword) < 5:
        print("Please use a keyword greater than 5 characters")
        exit(1)


def split_keyword_to_bits(keyword: str) -> tuple:
    """
    The padded '1' is to prevent dropping a 0
    while casting to int.  It will also be the seed.
    Technically, this makes the length of the arrays
    17 and 25 respectively.

    >>> split_keyword_to_bits('sassy')
    ([1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1], \
[1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1])
    >>> split_keyword_to_bits('#1 caN wr1t3 really long key')
    ([1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1], \
[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1])
    """
    keyword_bin = text_to_bits(keyword)
    key_16 = list(map(int, "1" + keyword_bin[:16]))
    key_24 = list(map(int, "1" + keyword_bin[16:40]))
    return (key_16, key_24)


def run_lfsr(text_bin: list, key: list, poly: tuple) -> list:
    """
    The lfsr is generated by the key and tap/polynomial,
    this function is re-used for both LFSRs.

    Think of it as a set of bits the size of the key
    that are cycled, where a tap/polynomial is pulsed
    and the result is checked with a basic mode % 2.
    The result is deterministic and runs for the length of
    the binary plaintext length.

    >>> run_lfsr([0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, \
0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1], \
[1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], (16, 2))
    [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, \
1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0]
    """
    lfsr = []
    for bit in text_bin:
        xor = sum(key[num] for num in poly)
        xor = 0 if xor % 2 == 0 else 1
        lfsr.append(xor)
        key.insert(0, xor)
        del key[-1]
    return lfsr


def run_full_adder(text_bin: list, lfsr_16: list, lfsr_24: list) -> list:
    """
    This function follows the standard full adder truth table.
    Based on the values of input bits, the values of output
    bits can be directly assigned.  This process utilizes bits
    from both LFSRs and a carry-in bit (cin) initialized at 0.
    The full adder will run for the duration of the binary plaintext
    or ciphertext length.

    >>> run_full_adder([0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, \
0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1], \
[1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, \
1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], \
[1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, \
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1])
    [0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, \
1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0]
    """
    cin = 0
    crypt_bin = []
    for i, bit in enumerate(text_bin):
        lfsr_cin_sum = lfsr_16[i] + lfsr_24[i] + cin
        s = 0 if lfsr_cin_sum == 0 or lfsr_cin_sum == 2 else 1
        cout = 0 if lfsr_cin_sum == 0 or lfsr_cin_sum == 1 else 1
        crypt_bin.append((s + bit) % 2)
        cin = cout
    return crypt_bin


def init_keys_lfsr(plaintext_bin: list, key_16: list, key_24: list) -> tuple:
    """
    Create both LFSR results from the keys and the
    polynomials provided.

    The polynomials mark arrays at the positions
    to perform the mod calculation, then the register
    shifts.  This continues for the duration of
    the binary plaintext.

    Keep in mind that the lfsr arrays will not be their key sizes,
    but the size of the binary plaintext.

    >>> init_keys_lfsr([0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, \
0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, \
1, 1, 1, 1], [1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], \
[1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1])
    ([1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, \
1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], \
[1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, \
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1])
    """
    poly_17 = (16, 2)
    poly_25 = (24, 7, 5, 1)
    lfsr_16 = run_lfsr(plaintext_bin, key_16, poly_17)
    lfsr_24 = run_lfsr(plaintext_bin, key_24, poly_25)
    return (lfsr_16, lfsr_24)


def run_css(plaintext: str, keyword: str) -> tuple:
    """
    Perform the whole CSS process, see the comments below.
    """
    # Binarize plaintext
    plaintext_bin = list(map(int, text_to_bits(plaintext)))

    # Binarize keyword
    key_16, key_24 = split_keyword_to_bits(keyword)

    # Initialize LFSRs
    lfsr_16, lfsr_24 = init_keys_lfsr(plaintext_bin, key_16, key_24)

    # Encyrption: Full Adder Binary Plaintext to Obtain Ciphertext
    ciphertext_bin = run_full_adder(plaintext_bin, lfsr_16, lfsr_24)
    ciphertext = text_from_bits("".join(map(str, ciphertext_bin)))

    # Decryption: Full Adder Ciphertext to Obtain Decrypted Ciphertext
    dectext_bin = run_full_adder(ciphertext_bin, lfsr_16, lfsr_24)
    dectext = text_from_bits("".join(map(str, dectext_bin)))
    return (ciphertext, dectext)


def main():
    # Initialize keyword and plaintext
    keyword = input("Please enter a keyword of any 5 characters: ")
    check_keyword(keyword)
    plaintext = input("Please enter your message: ")

    # Run the process
    ciphertext, dectext = run_css(plaintext, keyword)

    # Print the results
    print("\nEncrypted: ", ciphertext)
    print("\nDecrypted: ", dectext)


if __name__ == "__main__":
    main()

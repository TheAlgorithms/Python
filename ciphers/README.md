# Шифры (Ciphers)

Шифры используются для защиты данных от людей, которым не разрешен доступ к ним. Они повсеместно используются в интернете для защиты ваших соединений.

## Алгоритмы

### `a1z26.py`
Этот скрипт реализует шифр A1Z26, который представляет собой простой шифр замены, где каждая буква заменяется ее порядковым номером в алфавите (A=1, B=2, C=3 и т.д.).

### `affine_cipher.py`
Этот скрипт реализует аффинный шифр, тип моноалфавитного шифра замены. Функция шифрования — `(ax + b) mod m`, где `a` и `b` — ключи шифра, а `m` — размер алфавита.

### `atbash.py`
Этот скрипт реализует шифр Атбаш, простой шифр замены, в котором алфавит переворачивается. Первая буква становится последней, вторая — предпоследней и так далее.

### `autokey.py`
Этот скрипт реализует шифр с автоключом, который является полиалфавитным шифром замены. Он похож на шифр Виженера, но использует сам открытый текст для расширения ключа. Короткий начальный ключ добавляется к началу открытого текста для создания полного ключа.

### `baconian_cipher.py`
Этот скрипт реализует шифр Бэкона, метод стеганографии (сокрытия сообщения), разработанный Фрэнсисом Бэконом. Каждая буква открытого текста заменяется последовательностью из пяти символов «A» и «B».

### `base16.py`
Этот скрипт предоставляет функции для кодирования и декодирования в Base16 (шестнадцатеричный формат). Base16 используется для представления двоичных данных в формате строки ASCII путем преобразования данных в последовательность шестнадцатеричных цифр.

### `base32.py`
Этот скрипт предоставляет функции для кодирования и декодирования в Base32. Base32 представляет двоичные данные с использованием 32-символьного набора. Он часто используется в средах, где важна нечувствительность к регистру.

### `base64.py`
Этот скрипт предоставляет функции для кодирования и декодирования в Base64. Base64 — это широко используемый метод кодирования двоичных данных в формат строки ASCII путем преобразования их в 64-ричное представление.

### `base85.py`
Этот скрипт предоставляет функции для кодирования и декодирования в Base85 (также известного как Ascii85). Base85 — это форма кодирования двоичных данных в текст, которая более эффективна по объему, чем Base64.

### `beaufort_cipher.py`
Этот скрипт реализует шифр Бофора, который является полиалфавитным шифром замены, похожим на шифр Виженера. Он использует tabula recta (квадратную таблицу алфавитов) для шифрования и дешифрования. Шифр Бофора является реципрокным, что означает, что процессы шифрования и дешифрования идентичны.

### `bifid.py`
Этот скрипт реализует бифидный шифр, фракционный шифр, который сочетает в себе квадрат Полибия с транспозицией. Сначала он преобразует буквы в их координаты в квадрате, затем записывает эти координаты в ряд и, наконец, преобразует пары координат обратно в буквы.

### `brute_force_caesar_cipher.py`
Этот скрипт выполняет атаку полным перебором (brute-force) на сообщение, зашифрованное шифром Цезаря. Он расшифровывает сообщение, используя каждый возможный ключ (от 0 до 25), и выводит все возможные варианты открытого текста, позволяя человеку определить правильный.

### `caesar_cipher.py`
Этот скрипт предоставляет функции для шифрования и дешифрования сообщений с использованием шифра Цезаря, простого шифра замены, в котором каждая буква смещается на определенное количество позиций по алфавиту. Он также включает функцию полного перебора для проверки всех возможных ключей.

### `cryptomath_module.py`
Этот скрипт предоставляет функцию для нахождения модульного мультипликативного обратного числа. Это распространенная математическая операция, используемая в криптографии, в частности, в таких шифрах, как аффинный шифр и RSA.

### `decrypt_caesar_with_chi_squared.py`
Этот скрипт предоставляет более продвинутый метод взлома шифра Цезаря. Вместо простого полного перебора с последующей интерпретацией человеком, он использует статистику хи-квадрат для программного определения наиболее вероятного открытого текста. Это достигается путем сравнения частот букв в расшифрованном тексте с известными частотами букв языка (по умолчанию английского).

### `deterministic_miller_rabin.py`
Этот скрипт реализует детерминированную версию теста на простоту Миллера-Рабина. для чисел в определенном диапазоне (примерно до 3.32e24) он может однозначно определить, является ли число простым. для больших чисел он может дать вероятностный результат.

### `diffie.py`
Этот скрипт представляет собой базовую реализацию обмена ключами Диффи-Хеллмана. Он включает в себя функцию для нахождения примитивного корня по модулю простого числа, что является необходимым компонентом алгоритма. Основная часть скрипта демонстрирует процесс обмена ключами между двумя сторонами, A и B.

### `diffie_hellman.py`
Этот скрипт предоставляет более надежную, классо-ориентированную реализацию протокола обмена ключами Диффи-Хеллмана. Он использует предопределенные, стандартизированные простые числа и генераторы из RFC 3526 для различных уровней безопасности (например, 2048-битные, 4096-битные). Он также включает методы для проверки ключей и генерирует общий секрет путем хеширования результата.

### `elgamal_key_generator.py`
Этот скрипт генерирует открытый и закрытый ключи для системы шифрования Эль-Гамаля. Он включает в себя генерацию большого простого числа, нахождение примитивного корня по модулю этого простого числа, а затем вычисление ключей на основе случайно выбранного закрытого ключа. Сгенерированные ключи сохраняются в текстовые файлы.

### `enigma_machine2.py`
Этот скрипт представляет собой эмуляцию знаменитой шифровальной машины "Энигма", использовавшейся Германией во Второй мировой войне. Он имитирует ключевые компоненты "Энигмы", включая роторы, рефлектор и коммутационную панель (plugboard). Скрипт позволяет настраивать выбор роторов, их начальные позиции и параметры коммутационной панели. Благодаря рефлектору, процессы шифрования и дешифрования идентичны.

### `fractionated_morse_cipher.py`
Этот скрипт реализует шифр дробного Морзе. Этот шифр сначала преобразует открытый текст в код Морзе, разделяет код Морзе символом 'x', а затем группирует строку Морзе в триграммы (группы по три). Каждая триграмма затем заменяется буквой из ключевого алфавита. Этот процесс "дробит" исходные буквы, делая шифр более надежным, чем простая замена.

### `hill_cipher.py`
Этот скрипт реализует шифр Хилла, полиграфический шифр замены, основанный на линейной алгебре. Он использует матрицу в качестве ключа. Открытый текст разбивается на блоки, которые преобразуются в векторы. Каждый вектор затем умножается на ключевую матрицу для получения вектора шифротекста. Расшифровка выполняется путем умножения на обратную матрицу ключа.

### `mixed_keyword_cypher.py`
Этот скрипт реализует шифр со смешанным ключевым словом. Он создает алфавит для шифра замены, сначала записывая ключевое слово (с удаленными повторяющимися буквами), а затем заполняя оставшуюся часть алфавита остальными буквами. Этот смешанный алфавит затем располагается в виде сетки, и окончательное сопоставление для замены создается путем считывания сетки по столбцам.

### `mono_alphabetic_ciphers.py`
Этот скрипт предоставляет общую основу для моноалфавитных шифров замены. Он принимает ключ, который представляет собой перемешанную версию алфавита, и использует его для шифрования или дешифрования сообщения. Шифры Цезаря, Атбаш и ключевого слова являются частными случаями моноалфавитных шифров замены.

### `morse_code.py`
Этот скрипт предоставляет функции для перевода текста в код Морзе и обратно. Он использует словарь для сопоставления символов с их соответствующими сериями точек и тире.

### `onepad_cipher.py`
Этот скрипт реализует разновидность шифра Вернама (одноразового блокнота). Однако важно отметить, что это не истинный одноразовый блокнот, поскольку он использует генератор псевдослучайных чисел для создания ключа. Настоящий одноразовый блокнот требует предварительно разделенного, действительно случайного ключа той же длины, что и сообщение. Формула шифрования, используемая здесь, также является нестандартной.

### `permutation_cipher.py`
Этот скрипт реализует перестановочный шифр, который является разновидностью шифра транспозиции. Сообщение делится на блоки фиксированного размера, и символы в каждом блоке переставляются в соответствии с ключом-перестановкой.

### `playfair_cipher.py`
Этот скрипт реализует шифр Плейфера, ручной симметричный метод шифрования, который был первым шифром, использующим замену пар букв (диграмм). Он шифрует пары букв, а не отдельные буквы, как в простых шифрах замены. Метод использует таблицу 5x5, содержащую ключевое слово или фразу.

### `polybius.py`
Этот скрипт реализует шифр квадрата Полибия. Это шифр замены, который использует сетку 5x5 (квадрат Полибия) для преобразования букв в пары чисел. Этот скрипт может как кодировать, так и декодировать сообщения.

### `porta_cipher.py`
Этот скрипт реализует шифр Порты, полиалфавитный шифр замены, использующий ключевое слово. Алфавит делится на две половины, и в зависимости от буквы ключа выполняется определенная взаимная замена. Это реципрокный шифр, что означает, что процессы шифрования и дешифрования идентичны.

### `rabin_miller.py`
Этот скрипт реализует тест на простоту Рабина-Миллера, вероятностный алгоритм для определения, является ли число простым. Он широко используется в криптографии для генерации больших простых чисел. Скрипт также включает функцию для генерации больших простых чисел заданного размера ключа.

### `rail_fence_cipher.py`
Этот скрипт реализует шифр "железнодорожной изгороди", разновидность шифра транспозиции. Свое название он получил из-за способа шифрования: буквы открытого текста записываются зигзагом или "изгородью" по нескольким "рельсам" (ключ), а затем считываются ряд за рядом.

### `rot13.py`
Этот скрипт реализует шифр ROT13, частный случай шифра Цезаря, где сдвиг составляет 13 позиций. Применение ROT13 к тексту, а затем повторное его применение восстанавливает исходный текст, поэтому одна и та же функция может использоваться как для шифрования, так и для дешифрования.

### `rsa_cipher.py`
Этот скрипт реализует алгоритм RSA (Ривест-Шамир-Адлеман), широко используемую криптосистему с открытым ключом. Он предоставляет функции для шифрования и дешифрования сообщений. Процесс включает в себя преобразование сообщения в блоки целых чисел, выполнение модульного возведения в степень с открытым или закрытым ключом, а затем преобразование блоков обратно в текст. Он также включает функции для чтения ключей из файлов и для шифрования/дешифрования содержимого файлов.

### `rsa_factorization.py`
Этот скрипт реализует алгоритм для эффективного нахождения простых множителей (`p` и `q`) модуля RSA `N`, если известны открытая экспонента `e` и закрытая экспонента `d`. Это демонстрирует математическую связь между открытым и закрытым ключами и простыми множителями модуля.

### `rsa_key_generator.py`
Этот скрипт генерирует пары открытого и закрытого ключей для алгоритма RSA. Он следует стандартной процедуре: генерация двух больших простых чисел, вычисление модуля `n` и функции Эйлера `phi(n)`, выбор открытой экспоненты `e`, а затем вычисление закрытой экспоненты `d` как модульного мультипликативного обратного для `e`. Затем ключи сохраняются в файлы.

### `running_key_cipher.py`
Этот скрипт реализует шифр с бегущим ключом, разновидность полиалфавитного шифра замены. Он похож на шифр Виженера, но вместо короткого, повторяющегося ключевого слова, он использует длинный отрывок текста (например, из книги) в качестве ключа. Ключ имеет ту же длину, что и открытый текст.

### `shuffled_shift_cipher.py`
Этот скрипт реализует модифицированную версию шифра Цезаря. Он нацелен на большую безопасность за счет использования пароля для перемешивания алфавита, используемого для замены. Ключ сдвига также получается из пароля. Это значительно усложняет атаку полным перебором по сравнению со стандартным шифром Цезаря.

### `simple_keyword_cypher.py`
Этот скрипт реализует простой шифр с ключевым словом. Ключевое слово используется для создания смешанного алфавита для моноалфавитной замены. Сначала записывается ключевое слово (с удаленными дубликатами), а затем остальные буквы алфавита в их обычном порядке.

### `simple_substitution_cipher.py`
Этот скрипт реализует простой шифр замены. Он использует ключ, который является перестановкой алфавита. Каждая буква в открытом тексте заменяется буквой, находящейся на той же позиции в ключе. Это общая реализация моноалфавитного шифра замены.

### `transposition_cipher.py`
Этот скрипт реализует шифр столбцовой транспозиции (разновидность маршрутного шифра). Открытый текст записывается в строки фиксированной длины (ключ), а затем шифротекст считывается столбец за столбцом.

### `transposition_cipher_encrypt_decrypt_file.py`
Этот скрипт служит утилитой командной строки для скрипта `transposition_cipher.py`. Он позволяет пользователю шифровать или дешифровать целый файл с использованием шифра столбцовой транспозиции.

### `trifid_cipher.py`
Этот скрипт реализует шифр Триффида, фракционный шифр, похожий на шифр Бифида, но использующий триграммы вместо диграмм. Каждая буква открытого текста преобразуется в триграмму (группу из трех чисел или символов), триграммы перемешиваются, а затем преобразуются обратно в буквы шифротекста.

### `vernam_cipher.py`
Этот скрипт реализует шифр Вернама, который является потоковым шифром. По сути, он идентичен шифру Виженера. Название "шифр Вернама" иногда используется для обозначения одноразового блокнота, но эта реализация использует повторяющийся ключ, что делает его шифром Виженера, а не истинным одноразовым блокнотом.

### `vigenere_cipher.py`
Этот скрипт реализует шифр Виженера, метод шифрования буквенного текста с использованием серии взаимосвязанных шифров Цезаря, основанных на буквах ключевого слова. Это форма полиалфавитной замены.

### `xor_cipher.py`
Этот скрипт реализует шифр XOR, простой аддитивный потоковый шифр. Каждый символ открытого текста подвергается операции XOR с ключом. Та же самая операция используется как для шифрования, так и для дешифрования. Эта реализация использует одно целое число в качестве повторяющегося ключа.

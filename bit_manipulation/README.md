# Побитовые операции (Bit Manipulation)

Побитовые операции — это действия, выполняемые над битами для обнаружения ошибок (код Хэмминга), шифрования и дешифрования сообщений (подробнее об этом в папке ciphers) или для выполнения любых действий на самом низком уровне вашего компьютера.

## Алгоритмы

### `binary_and_operator.py`
Этот скрипт выполняет побитовую операцию И над двумя целыми числами.

### `binary_coded_decimal.py`
Этот скрипт преобразует целое число из десятичной системы в его двоично-десятичное (BCD) представление. Каждая цифра числа представляется 4-битным двоичным числом.

### `binary_count_setbits.py`
Этот скрипт подсчитывает количество установленных битов (единиц) в двоичном представлении заданного целого числа.

### `binary_count_trailing_zeros.py`
Этот скрипт подсчитывает количество конечных нулей в двоичном представлении заданного целого числа.

### `binary_or_operator.py`
Этот скрипт выполняет побитовую операцию ИЛИ над двумя целыми числами.

### `binary_shifts.py`
Этот скрипт предоставляет функции для логического сдвига влево, логического сдвига вправо и арифметического сдвига вправо для целых чисел.

### `binary_twos_complement.py`
Этот скрипт вычисляет представление отрицательного целого числа в дополнительном коде (two's complement).

### `binary_xor_operator.py`
Этот скрипт выполняет побитовую операцию ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) над двумя целыми числами.

### `bitwise_addition_recursive.py`
Этот скрипт вычисляет сумму двух неотрицательных целых чисел с использованием побитовых операторов и рекурсии.

### `count_1s_brian_kernighan_method.py`
Этот скрипт подсчитывает количество установленных битов (единиц) в целом числе с использованием алгоритма Брайана Кернигана. Этот метод эффективен, так как он выполняет итерации только столько раз, сколько установлено битов.

### `count_number_of_one_bits.py`
Этот скрипт предоставляет два метода для подсчета количества установленных битов (единиц) в целом числе: один с использованием алгоритма Брайана Кернигана, а другой — с использованием оператора модуля. Он также включает в себя тест производительности для сравнения их эффективности.

### `excess_3_code.py`
Этот скрипт преобразует целое число из десятичной системы в его код с избытком-3 (Excess-3). Это делается путем добавления 3 к каждой цифре десятичного числа, а затем преобразования каждой цифры в ее 4-битное двоичное представление.

### `find_previous_power_of_two.py`
Этот скрипт находит наибольшую степень двойки, которая меньше или равна заданному целому числу.

### `gray_code_sequence.py`
Этот скрипт генерирует n-битную последовательность кода Грея. Код Грея — это такая система счисления, в которой два последовательных значения различаются только в одном бите.

### `highest_set_bit.py`
Этот скрипт возвращает позицию самого старшего установленного бита (наиболее значимого бита) числа.

### `index_of_rightmost_set_bit.py`
Этот скрипт возвращает индекс (начиная с нуля) самого правого установленного бита (наименее значимого бита) числа.

### `is_even.py`
Этот скрипт проверяет, является ли заданное целое число четным, проверяя наименее значимый бит. Если последний бит равен 0, число четное; в противном случае — нечетное.

### `is_power_of_two.py`
Этот скрипт проверяет, является ли заданное положительное целое число степенью двойки. Число является степенью двойки, если в его двоичном представлении установлен только один бит. Скрипт использует свойство, что для степени двойки `n`, `n & (n - 1)` всегда равно нулю.

### `largest_pow_of_two_le_num.py`
Этот скрипт находит наибольшую степень двойки, которая меньше или равна заданному числу. Он делает это, многократно сдвигая бит влево, пока значение не превысит заданное число.

### `missing_number.py`
Этот скрипт находит пропущенное число в списке последовательных целых чисел, используя побитовую операцию XOR.

### `numbers_different_signs.py`
Этот скрипт проверяет, имеют ли два целых числа противоположные знаки, используя побитовую операцию XOR. Если старший бит результата `num1 ^ num2` равен 1, числа имеют противоположные знаки.

### `power_of_4.py`
Этот скрипт проверяет, является ли заданное положительное целое число степенью 4. Число является степенью 4, если оно является степенью 2 и его единственный установленный бит находится на нечетной позиции.

### `reverse_bits.py`
Этот скрипт переворачивает биты 32-битного целого числа.

### `single_bit_manipulation_operations.py`
Этот скрипт предоставляет функции для управления одним битом в целом числе:
- `set_bit`: Устанавливает бит в заданной позиции в 1.
- `clear_bit`: Сбрасывает бит в заданной позиции в 0.
- `flip_bit`: Инвертирует бит в заданной позиции.
- `is_bit_set`: Проверяет, установлен ли бит в заданной позиции.
- `get_bit`: Получает значение бита в заданной позиции.

### `swap_all_odd_and_even_bits.py`
Этот скрипт меняет местами все нечетные и четные биты в целом числе. Например, бит 0 меняется с битом 1, бит 2 с битом 3 и так далее.

# Двоичное дерево (Binary Tree)

## Обход двоичного дерева (Binary Tree Traversal)

Сочетание двоичных деревьев как структур данных и обхода как алгоритма относится к классическим задачам, прямо или косвенно.

> Если вы сможете понять обход двоичных деревьев, обход других сложных деревьев станет для вас простым.

Ниже приведены некоторые распространенные способы обхода деревьев.

- **Обходы в глубину (DFS):** симметричный (in-order), прямой (pre-order), обратный (post-order)
- **Обход в ширину (BFS) или поуровневый обход**

И для DFS, и для BFS есть свои применения.

Стек можно использовать для упрощения процесса обхода DFS. Кроме того, поскольку дерево является рекурсивной структурой данных, рекурсия и стек — два ключевых момента для DFS.

## Алгоритмы и Структуры Данных

### `avl_tree.py`
Этот скрипт предоставляет реализацию АВЛ-дерева, которое является самобалансирующимся двоичным деревом поиска. В АВЛ-дереве высоты двух дочерних поддеревьев любого узла различаются не более чем на единицу. Это гарантирует, что дерево остается сбалансированным, и операции, такие как вставка, удаление и поиск, имеют временную сложность в худшем случае O(log n).

### `basic_binary_tree.py`
Этот скрипт предоставляет базовую реализацию двоичного дерева. Он включает класс `Node` и класс `BinaryTree` с методами для итерации по дереву (внутренний обход), получения его длины и глубины, а также проверки, является ли оно полным двоичным деревом.

### `binary_search_tree.py`
Этот скрипт предоставляет комплексную реализацию двоичного дерева поиска (BST). BST — это узловая структура данных, в которой левое поддерево узла содержит только узлы со значениями, меньшими значения узла, а правое — только со значениями большими. Эта реализация включает методы для вставки, поиска, удаления, нахождения минимума/максимума и различных обходов дерева.

### `binary_search_tree_recursive.py`
Этот скрипт предоставляет еще одну реализацию двоичного дерева поиска (BST), но эта использует рекурсию для своих основных операций, таких как вставка и поиск.

### `binary_tree_mirror.py`
Этот скрипт предоставляет функцию для создания зеркального отображения двоичного дерева. Он обходит дерево и меняет местами левого и правого потомков у каждого узла.

### `binary_tree_node_sum.py`
Этот скрипт вычисляет сумму значений всех узлов в двоичном дереве. Он делает это, выполняя обход дерева в глубину (DFS) и накапливая значения.

### `binary_tree_path_sum.py`
Этот скрипт находит количество путей в двоичном дереве, где сумма значений узлов вдоль пути равна заданному целевому значению. Пути не обязательно должны начинаться с корня или заканчиваться листом, но они должны идти вниз.

### `binary_tree_traversals.py`
Этот скрипт предоставляет реализации различных алгоритмов обхода двоичного дерева. Сюда входят стандартные обходы в глубину (прямой, внутренний, обратный), обход в ширину (поуровневый) и более специализированные обходы, такие как обратный внутренний и зигзагообразный.

### `diameter_of_binary_tree.py`
Этот скрипт вычисляет диаметр (или ширину) двоичного дерева. Диаметр определяется как количество узлов на самом длинном пути между любыми двумя узлами в дереве.

### `diff_views_of_binary_tree.py`
Этот скрипт предоставляет функции для получения различных "видов" двоичного дерева: вид слева, вид справа, вид сверху и вид снизу. Каждый вид показывает узлы, которые видны с этой конкретной перспективы.

### `distribute_coins.py`
Этот скрипт решает задачу "Распределение монет в двоичном дереве". Цель состоит в том, чтобы найти минимальное количество ходов, необходимое для того, чтобы в каждом узле была ровно одна монета.

### `fenwick_tree.py`
Этот скрипт предоставляет реализацию дерева Фенвика, также известного как двоичное индексированное дерево (BIT). Дерево Фенвика — это структура данных, которая может эффективно обновлять элементы и вычислять префиксные суммы за время O(log n).

### `flatten_binarytree_to_linkedlist.py`
Этот скрипт предоставляет функцию для "сглаживания" двоичного дерева в структуру, напоминающую связанный список, используя правые указатели узлов и устанавливая левые в `None`.

### `floor_and_ceiling.py`
Этот скрипт предоставляет функцию для нахождения "пола" (наибольшего элемента, меньшего или равного ключу) и "потолка" (наименьшего элемента, большего или равного ключу) для заданного ключа в двоичном дереве поиска.

### `inorder_tree_traversal_2022.py`
Этот скрипт предоставляет реализацию внутреннего обхода (in-order) для двоичного дерева поиска, при котором узлы посещаются в порядке возрастания их значений.

### `is_sorted.py`
Этот скрипт предоставляет функцию для проверки, является ли двоичное дерево действительным двоичным деревом поиска (BST).

### `is_sum_tree.py`
Этот скрипт предоставляет функцию для проверки, является ли двоичное дерево "деревом сумм", где значение каждого узла, не являющегося листом, равно сумме значений в его поддеревьях.

### `lazy_segment_tree.py`
Этот скрипт реализует дерево отрезков с отложенным распространением (Lazy Propagation) для эффективного выполнения запросов и обновлений на диапазоне.

### `lowest_common_ancestor.py`
Этот скрипт находит наименьшего общего предка (LCA) двух узлов в дереве, используя поиск в ширину и технику разреженной таблицы.

### `maximum_fenwick_tree.py`
Этот скрипт предоставляет реализацию дерева Фенвика, специально разработанного для запросов о максимуме на диапазоне.

### `merge_two_binary_trees.py`
Этот скрипт предоставляет функцию для слияния двух двоичных деревьев путем суммирования значений пересекающихся узлов.

### `mirror_binary_tree.py`
Этот скрипт предоставляет функцию для зеркального отображения двоичного дерева путем рекурсивной замены левых и правых потомков.

### `non_recursive_segment_tree.py`
Этот скрипт предоставляет нерекурсивную реализацию дерева отрезков, которая часто более эффективна на практике.

### `number_of_possible_binary_trees.py`
Этот скрипт вычисляет количество возможных двоичных деревьев и двоичных деревьев поиска, которые можно сформировать из заданного количества узлов, используя числа Каталана.

### `red_black_tree.py`
Этот скрипт предоставляет реализацию красно-черного дерева, еще одного типа самобалансирующегося двоичного дерева поиска, которое гарантирует логарифмическую сложность операций.

### `segment_tree.py`
Этот скрипт предоставляет рекурсивную реализацию дерева отрезков для эффективных запросов по диапазону.

### `segment_tree_other.py`
Этот скрипт предоставляет еще одну, более объектно-ориентированную реализацию дерева отрезков.

### `serialize_deserialize_binary_tree.py`
Этот скрипт предоставляет функции для сериализации двоичного дерева в строку и десериализации строки обратно в двоичное дерево.

### `symmetric_tree.py`
Этот скрипт предоставляет функцию для проверки, является ли двоичное дерево зеркальным отражением самого себя.

### `treap.py`
Этот скрипт предоставляет реализацию декартова дерева (Treap), рандомизированного двоичного дерева поиска, которое использует приоритеты для поддержания баланса.

### `wavelet_tree.py`
Этот скрипт предоставляет реализацию вейвлет-дерева, компактной структуры данных для эффективных запросов по диапазону, таких как запрос квантиля и ранга.
